# ArrayとString

## 1-1. Stringが全部同じCharacterでできていることを確認する

条件:

* 他のdata structureを使わない

### 方針

条件から、たぶんHashMap使うなよってことだろう。  

アルファベットの小文字を仮定。  
なので、Stringをループ回して、出現回数をbitfieldで管理する。  
フラグがたってる文字が出現したらfalseそうじゃなかったらtrue

`src/is_unique.py`

## 1-2. Stringを逆順にするreverse関数を作れ！

条件：

* stringはnullで終わる
* 言語はC or C++

### 方針

1. まずはStringの長さを取得する関数を作成する。(長さ=nullのindex-1)
2. 同じ長さのchar配列を作成する。
3. で逆順ループを回して2で作成したchar配列に格納する。

`src/reverse_string.c`

### 追記

やってみたけど、セグフォルト。  
答えを真似てみたけどセグフォルト・・・  
char配列にindex指定してchar代入の所でエラー発生。

### 追追記

mainで文字列をポインタで定義していたため。  
この場合、ポインタの指し示すアドレスはexecutableのアドレスになるため、  
文字列の変更が無理らしい。  

これを回避するには、stackもしくはheapをポインタが指すようにすればいいらしい。  
ということで定義を文字列の配列にしたらOK。  
もしくはmallocする手もある。

しかしなんでexecutableに入ってしまうのだろうかというと、  
ポインタに代入する場合、文字列は予め存在しなければダメだからのよう(たぶん)


## 1-3. string1とstring2がアナグラムかどうか確認する

### 方針

それぞれのcharacterがkeyで出現回数がvalueとなるHashMapを利用して、  
string1とstring2の出現回数を比較する。

`src/permutation.py`

## 1-4. 半角スペースを全部%20に変換

1. 文字列の前からループして最後の半角スペースでないところまでポインタを進める。
2. null文字までポインタを進める。
3. 2で取得したポインタからスタートして、1で取得したポインタとおしりのポインタをデクレメントしていく。
    * 1で取得したポインタが半角スペースでなければそのまんま内容を2で取得したポインタ位置に入れる
    * 半角スペースなら0, 2, %をいれる。

`src/space_encode.c`

## 1-5. 文字列を圧縮

aabbbcddaaaならa2b3c1d2a3のように圧縮。  
圧縮後が圧縮前より短くならない場合は、圧縮前の文字列を返す。

### 方針

文字列を前からループさせ以下のルールに従ってやってく。

* 1文字前と同じならカウントアップ
* 違ったら圧縮後文字列に前の文字とカウントをappendして、新しい文字を記録

`src/compression.c`

## 1-6. NxNのimageを90度ロテーションさせる

条件：

* 4byte per 1px

### 方針

1pxずつ移動させる。

1. 上辺の最も左をtemporary変数へ、右辺の最も上を上辺の最も左へ、下辺の最も右を右辺の最も上へ...
2. 上辺の左から2番めをtemporary変数へ...
3. 次のレイヤーの最も左から2番目を...

ってな感じで。

`src/rotation.c`

## 1-7. MxN行列の(i, j)要素が0だった場合、i行の要素、j列の要素すべてを0にする。

1. マスク行列を用意(全要素1)
2. MxN行列をいてレートし0の要素を探す。
3. 0の要素があった場合は、その要素の行、列のマスクを0にする。
4. 元の行列とマスクを&演算する。

`src/zero_matrix.c`

## 1-8. isSubstringを使ってstr2がstr1をロテーションしたものであることを確認する

1. str1を2個つなぐ
2. str2が1のsubstringであることを確認する。
3. substringならロテーションしたものである

"しーすー"を2回言うと、必ず1回は"すーしー"と言うのと同じ原理
