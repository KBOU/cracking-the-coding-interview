# ソートとサーチ

いろんな問題が出るらしいがほとんどが基本アルゴリズムの延長らしい。

## Bubble Sort

前後の要素を比較して後の要素のほうが小さければスワップする。

計算量： O(n^2)
メモリ使用量: O(1)

`src/sort.py`

## Selection Sort

配列をなめて一番小さい要素を左の要素とスワップ。  
つぎに2番目に小さい要素を左から2番目の要素とスワップ。  
と言った感じのソート。

計算量: O(n^2)
メモリ使用量: O(1)

`src/sort.py`

## Merge Sort

左半分をソートして、右半分をソートして  
それをマージしてソート完了というアルゴリズム。  
再帰的に行う

計算量: O(n log n)
メモリ使用量: ケースバイケース

`src/sort.py`

## Quick Sort

パーティションを選んで、パーティションより左側にはパーティションより小さい値を、  
パーティションより右側にはパーティションより大きい値が来るようにソートする。

半分のindexを選ぶ方法が違う。

`src/sort.py`


計算量: O(n log n) 最悪のケースO(n^2)
メモリ使用量: O(log n)

## Radix Sort

値の範囲が決まっている時に使う。  
例えば年齢ごとにソートとか。

計算量: O(kn) kは値の範囲
メモリ使用量: O(1)


`src/sort.py`

## Binary Search

2分木探索。

`src/binary_search.py`


## 11-1. ソートされた配列A, Bをマージしてソートされた配列A+Bを作る

* Bの長さはAの要素すべてが入ってもOKなくらい大きいとする。

マージソートと同じなのでは?

`src/extend_sort.py`


## 11-2. Stringの配列をソートしてアナグラムが隣り合うようにしたい

疑問

* a-zだけでいいか？(もしくはASCII)

アナグラムって結局なんだろうというと文字列を分解した時、  
それぞれの文字の出現回数が同じもののこと。

### 方針

1. "a"の個数を調べて、個数ごとにサブグループ化
2. サブグループごとに"b"の個数を調べてbの個数でさらにサブグループ化
3. サブグループ内の要素数が1になった場合、調査が"z"まで行った場合、調査済みの文字の個数が文字列長となった場合、調査終了
4. サブグループをマージする。

`src/anagram.py`

## 11-3. rotateされたソート済み配列の中から指定した要素を見つける！

前から順にみればわかるけど、計算量的な問題でバイナリサーチしたい。  

1. rotate前に先頭にあった要素の今のINDEXを取得
2. 取得したINDEXより元の配列を生成
3. rotate前配列をバイナリサーチ
4. rotate indexとバイナリサーチで取得したインデックスをたす

`src/search_rotated.py`


### 追記

配列に同じ数値があった場合を考慮していない

## 11-4. 20GBのファイルのソート

メモリだけではソートできなさそうなので、分割してソートしていき、  
ソート結果をファイル出力し、それをまたソートしていき、全体的にソートしていくこととする。

メモリを5GB使えるとすると、

1. ファイルを5GBずつ読み込んで、5GBずつソートして結果をファイル出力
2. 出力ファイルの前半1/4ずつ読み込んで、ソートするしてファイル出力。
3. そうすると全体の1/16はソートされたことになる。(後半1/4も同時に読み込むと後半1/16もソートされたことになり全体の1/8がソートされる)
4. これを繰り返す。

## 11-5. スパースなソートされた配列をバイナリサーチする

バイナリサーチして""にあたったら、""以外の文字列を得るまで両側をサーチし、  
""以外の文字を得たら普通にバイナリサーチする。  
を繰り返す。

`src/sperse_search.py`

## 11-6. MxNのマトリックスをバイナリサーチ

条件:

* A[i][j+1] &ge; A[i][j]
* A[i+1][j] &ge; A[i][j]

の条件を満たすMxNマトリックスをサーチ。

### 方針

対角線上をサーチしていき、A[i][j] &lt; x (探している数) &lt; A[i+1][j+1]、  
となったら対角線で区切った左下のボックスと右上のボックスをまたバイナリサーチしていく。

こんなイメージ。  
x = 8  
MxNマトリックス

<table>
  <tr> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> </tr>
  <tr> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>10</td> </tr>
  <tr> <td>3</td> <td>6</td> <td>9</td> <td>12</td> <td>15</td> </tr>
  <tr> <td>4</td> <td>8</td> <td>12</td> <td>16</td> <td>20</td> </tr>
</table>

* 1回目: x &gt; A[1][1] = 4
* 2回目: x &lt; A[2][2] = 9
* 次は左下の
<table>
  <tr> <td>3</td> <td>6</td> </tr>
  <tr> <td>4</td> <td>8</td> </tr>
</table>
と右上の
<table>
  <tr> <td>4</td> <td>5</td> </tr>
  <tr> <td>8</td> <td>10</td> </tr>
</table>
の2つのボックスからさーちする。


`src/matrix_search.py`

## 11-7. 人を積み上げて最も高くする

条件

* Aさんより背が低くかつ体重も軽い人しかAさんの上にはのれない

### 方針

1. まずは身長で逆順にソートする
2. タワーを作っていき、身長、体重が軽い人は上に乗れる
3. 無理だったら新しいタワーを作る
4. 最後にタワーの人数を比べる

`src/tallest_tower.py`
