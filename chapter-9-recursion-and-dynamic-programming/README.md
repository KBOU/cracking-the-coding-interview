# 再帰と動的計画

再帰を使うとスタックに積み上がっていくケースが多いので、  
そこらへんをちゃんと処理するとか結果をキャッシュするとか考える必要がある。

## 9-1. N段の階段を登り詰めるには何通りあるか

条件：

* 登り方は1段ずつ,2段ずつ、3段ずつのいずれか
* 降りはしないだろう

### N=1

* [1]

1通り

### N=2

* [1, 1]
* [2]

2通り

### N=3

* [1, 1, 1]
* [2, 1]
* [3]
* [1, 2]

4通り

### 方針

N段目に到達する場合の数をf(N)とすると  

`f(N) = f(N-1) + f(N-2) + f(N-3)`

ということでしょう。ここでf(0) = 1、f(0未満) = 0とおく。  
N=4だと

`f(4) = f(3) + f(2) + f(1) = 4 + 2 + 1 = 7`

になるはず

### ためしにN=4

* [1, 1, 1, 1]
* [2, 1, 1]
* [3, 1]
* [1, 2, 1]
* [1, 1, 2]
* [2, 2]
* [1, 3]

### という方針で実装してみる

`src/climb_step.py`


## 9-2. (0, 0)から(X, Y)へ進む方法は何通りあるか

条件：

* 1ずつ進む
* 1度に進むのはX方向に+1かY方向に+1のみ。つまり上か右に直進あるのみ
* 【発展】通行止めがある場合はどうするか？

### 方針

とりあえず発展は無視すると、  
xCyの組み合わせの数でいけるはず。(再帰ではないのでは・・・)  

なので、発展を考えると、  
f(x, y)を(x, y)に進む場合の数とすると、

`f(x, y) = f(x-1, y) + f(x, y-1)`

となるはず。

### 実装

`src/combination.py`


## 9-3. A[i] = iとなるようなiを配列から探す

### 重複がない場合は

バイナリサーチ

### 重複がある場合は、

<table>
  <tr> <th>index</th> <td>0</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> </tr>
  <tr> <th>data</th> <td>-2</td> <td>3</td> <td>3</td> <td>4</td> <td>4</td> <td>5</td> </tr>
</table>

のようなデータが有った場合は、  
index=0から順にdataを見て、  
dataの数値がindexより大きかったら  
A[data]のdataを見るというのを繰り返せばよいのではないでしょうか。

なぜなら、index=dataとなるまで、index&lt;dataは確実なので。

### 追記

重複があってもバイナリサーチはできるようです・・・


## 9-4. すべてのサブセットを返すメソッド

`src/subset.py`

## 9-5. 文字列の順番を入れ変えた全パターンを表示する

### 目的

"abc"のような文字列があった場合、

* abc
* acb
* bac
* bca
* cab
* cba

という感じで1文字ずつ並べ替えた前パターンを表示する。  
以降少しずつ考えてみます。

### N=2の時

* ab
* ba

の2パターン

### N=3の時

結果としては上述のパターンとなるのだが、N=2を活かしたい。

N=3のパターンは  
N=2のabの頭、真ん中、お尻のいずれかにcを突っ込んだもの  
もしくはbaの頭、真ん中、お尻のいずれかにcを突っ込んだもの  
と言い表すことができる。

### 実装

`src/permutation.py`
