# 再帰と動的計画

再帰を使うとスタックに積み上がっていくケースが多いので、  
そこらへんをちゃんと処理するとか結果をキャッシュするとか考える必要がある。

## 9-1. N段の階段を登り詰めるには何通りあるか

条件：

* 登り方は1段ずつ,2段ずつ、3段ずつのいずれか
* 降りはしないだろう

### N=1

* [1]

1通り

### N=2

* [1, 1]
* [2]

2通り

### N=3

* [1, 1, 1]
* [2, 1]
* [3]
* [1, 2]

4通り

### 方針

N段目に到達する場合の数をf(N)とすると  

`f(N) = f(N-1) + f(N-2) + f(N-3)`

ということでしょう。ここでf(0) = 1、f(0未満) = 0とおく。  
N=4だと

`f(4) = f(3) + f(2) + f(1) = 4 + 2 + 1 = 7`

になるはず

### ためしにN=4

* [1, 1, 1, 1]
* [2, 1, 1]
* [3, 1]
* [1, 2, 1]
* [1, 1, 2]
* [2, 2]
* [1, 3]

### という方針で実装してみる

`src/climb_step.py`


## 9-2. (0, 0)から(X, Y)へ進む方法は何通りあるか

条件：

* 1ずつ進む
* 1度に進むのはX方向に+1かY方向に+1のみ。つまり上か右に直進あるのみ
* 【発展】通行止めがある場合はどうするか？

### 方針

とりあえず発展は無視すると、  
xCyの組み合わせの数でいけるはず。(再帰ではないのでは・・・)  

なので、発展を考えると、  
f(x, y)を(x, y)に進む場合の数とすると、

`f(x, y) = f(x-1, y) + f(x, y-1)`

となるはず。

### 実装

`src/combination.py`


## 9-3. A[i] = iとなるようなiを配列から探す

### 重複がない場合は

バイナリサーチ

### 重複がある場合は、

<table>
  <tr> <th>index</th> <td>0</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> </tr>
  <tr> <th>data</th> <td>-2</td> <td>3</td> <td>3</td> <td>4</td> <td>4</td> <td>5</td> </tr>
</table>

のようなデータが有った場合は、  
index=0から順にdataを見て、  
dataの数値がindexより大きかったら  
A[data]のdataを見るというのを繰り返せばよいのではないでしょうか。

なぜなら、index=dataとなるまで、index&lt;dataは確実なので。

### 追記

重複があってもバイナリサーチはできるようです・・・


## 9-4. すべてのサブセットを返すメソッド

`src/subset.py`

## 9-5. 文字列の順番を入れ変えた全パターンを表示する

### 目的

"abc"のような文字列があった場合、

* abc
* acb
* bac
* bca
* cab
* cba

という感じで1文字ずつ並べ替えた前パターンを表示する。  
以降少しずつ考えてみます。

### N=2の時

* ab
* ba

の2パターン

### N=3の時

結果としては上述のパターンとなるのだが、N=2を活かしたい。

N=3のパターンは  
N=2のabの頭、真ん中、お尻のいずれかにcを突っ込んだもの  
もしくはbaの頭、真ん中、お尻のいずれかにcを突っ込んだもの  
と言い表すことができる。

### 実装

`src/permutation.py`


## 9-6. インプットされた数の()の組み合わせ

### N=1の場合

* ()

の1通り

### N=2の場合

* ()()
* (())


の2通り

### N=3の場合

* ()()()
* (())()
* ()(())
* (()())
* ((()))

の5通り


### 方針

* 文字列を左から見ていくと必ず "("の個数 &gt;= ")"の個数
* "("を+1、")"を-1として左から足していったら、  
最初が1で、どこをとっても必ず0以上で、最後は0となる組み合わせが()の成立する条件。

ってことでなんとか解けないだろうか・・・

`src/parens.py`

## 9-7. 周りの色を選択した色で塗りつぶしていくプログラム

条件

* スクリーンと選択したポイントと新しい色が与えられる
* 選んだポイントと違う色のポイントは色変更しない

### 方針

与えられたポイントを囲む8コマがそれぞれオリジナルカラーと同じなら塗りつぶす。  
で塗りつぶした8コマの一こまずつに対して同じ事を繰り返す。


`src/fill_color.py`

## 9-8. 25, 10, 5, 1セント硬貨の組み合わせてNセントにする。そのときの組み合わせの数を求める

### 方針

一番コインの枚数が少なくなる方向から考えていく。  
例えば、102セントの場合、

`102 / 25 = 4 ... 2`

一番コインの枚数が少ないのは、  
[4, 0, 0, 2]の組み合わせとなる。

次に少ないのは、
[3, 2, 1, 2]となる。

と言った感じでやっていく。

`src/changes.py`

## 9-9. チェスのクイーンを縦横斜めでかぶらないように8x8のチェスボードに置く

1. 1番上の段の任意の場所に一つおく
2. 2番目の段の任意の場所に一つ置く。ただし1番上の段によって置けなくなった場所は除く
3. 三番目の....
4. 9段目に到達したらクイーンのx座標一覧をを返す

て感じで行けば解けるはず

### 追記

だめだった。というのもメモリが足りないかなんかで動かなかった。  
各行に1コマしかないから1次元配列でいけるよう。

`src/chess_queen.py`
