# LinkedList

## テクニック

### Runnerテクニック

進みの違うループを回して該当する位置を探すテクニック。  
例えばLinkedListの真ん中の要素が欲しい時、  
かたっぽはstep=1でループを回して、もう一方はstep=2で回すと、  
step=2で回したほうが終端に達した時にstep=1のほうはちょうど真ん中にいる。

## 2-1. LinkedListの重複する要素を削除する。

条件：

* Listはソートされてない
* bufferを使っちゃダメ

### 方針

bufferを使っちゃダメということは、HashMapとか使っちゃダメということだろう。
二重ループ回して、

1. 1つ目の要素と2つ目の要素を比較
2. 1つ目の要素を3つ目の要素と比較
3. ........

て感じでいこうと思います。

`src/no_dup_list.c`

## 2-2. LinkedListで最後からｋ番目の要素を取得する。

条件：

* 単方向リスト


### 方針

Runnerを2つ回す。

1つめは、step=1で回し、  
2つめは、1つめがk回ループした時にstep=1でスタートする。

`src/kth_to_last.c`

## 2-3. 指定した要素を削除する。

条件：

* 単方向リスト
* 指定した要素にしかアクセス出来ない

### 方針

削除する要素の次の要素のデータ、次の要素の次の要素を要素の次の要素にする。

`src/delete_elem.c`


## 2-4. xの値を境にxより値が小さな要素はx以上の要素より必ず前に来るように配置する

### 方針

1. xより小さいLinkedlistとxより大きなLinkedlistを定義する
2. linkedlistを前からイテレートしていき、xより小さかったら小さいLInkedlistに大きかったら大きいLinkedlistにappend
3. ２つのlinkedlistを合併する

`src/partition.c`

## 2-5. LinkedListに1桁ずつ数字を入れて足し算してみる。

1の位がLinkedListの頭で10の位、100の位がそれに続く場合。  
この場合、単純そう。  
逆の場合をやってみる。(100の位、10の位、1の位と続く場合)

### 方針

1. まずはループを回して最大桁数を取得する。
2. 最大桁数に満たない方のLinkedListはheadに0のLinkedListを足りない分だけ付け加える
3. と同時に繰り上がりLinkedListを同じ桁数+1の長さで作成する。値は0
4. 2つのLinkedListを足し算する。繰り上がりは繰り上がりLinkedListに記憶
5. 繰り上がりLinkedListと足し算済みLinkedListを足し算する。
6. 繰り上がりLinkedListの値が全部0になるまで足し算する。

`src/addition.c`
