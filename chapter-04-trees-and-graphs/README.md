# Tree構造とグラフ

## 4-1. 木がバランスされているかどうかを確認する。

条件：

* バランスされている条件はどのサブツリーの高さも最大で1しか変わらない 

### 方針

サブツリーで左右の高さを比較し1より大きかったらNG

`src/is_balanced.py`

## 4-2. 有向グラフでAとBを結ぶ線があるかどうかを探す。

### 方針

幅優先探索でAからBにたどり着けるかやってみる。

`src/directed_graph.py`

## 4-3. ソートされた配列から高さが最小の2分探索木を作成する

### 方針

ということはrootがど真ん中の値、  
そして左側のサブツリーのrootは配列を真ん中で切った左側のどまんなかの値、  
そして右側のサブツリーのrootは配列を真ん中で切った右側のどまんなかの値、  
というのを繰り返せば良い。

`src/binary_search_tree.py`

## 4-4. 2分木の深さが同じNodeをLinkedListで串刺しにする

### 方針

* 深さ優先サーチで深さをインクリメントしながらサーチ
* 該当する深さのLinkedListに要素をadd

`src/skewered_tree.py`

## 4-5. 2分木と2分探索木の違いを見分ける

違いは2分探索木の場合、どの要素をとっても  
左のサブツリー &lt; 中 &lt; 右のサブツリー  
となっている点である。

### 方針

じゃどうやって探すか・・・  

1. rootと左のサブツリーの最大要素を比較しrootのほうが大きいことを確認する
2. rootと右のサブツリーの最小要素を比較しrootのほうが小さいことを確認する
3. というのを再帰的に行う

`src/is_bstree.py`

## 4-6. 指定したノードより一つ大きな要素を求める

条件：

* 二分探索木

### 方針

右下に要素があれば、右下の左下を再帰的に確認する。  
右下に要素がなければ、親要素か親の親の・・・右要素がひとつ大きい要素。

`src/find_next.py`
